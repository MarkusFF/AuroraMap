<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASA Aurora data Forecast Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://unpkg.com/versor"></script>
    <style>
        body {
            background-color: black;
            margin: 0;
            padding: 0;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #map {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            transition: opacity 0.3s ease;
            opacity: 0;
        }
        select, #show-location {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px;
            margin-bottom: 5px;
        }
        #metadata {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            z-index: 1000;
        }
        #colorbar-container {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            height: 200px;
            z-index: 1000;
        }
        #colorbar {
            width: 80px;
            height: 200px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <!-- <select id="projection-select">
            <option value="orthographic">Orthographic</option>
            <option value="equalEarth">Equal Earth</option>
            <option value="robinson">Robinson</option>
            <option value="mollweide">Mollweide</option>
        </select><br> -->
        <label>
            <input type="checkbox" id="show-location"> Show my location
        </label>
    </div>
    <div id="map">
        <canvas id="globe"></canvas>
        <div id="metadata"></div>
        <div id="colorbar-container">
            <canvas id="colorbar"></canvas>
        </div>
    </div>

    <script>
        let width = window.innerWidth;
        let height = window.innerHeight;

        const COUNTRY_FILL = "#90EE9005";
        const SPHERE_FILL = "rgba(0, 0, 0, 0.1)";
        const COUNTRY_BORDER_STROKE = "#444444";
        const canvas = d3.select("#globe")
            .attr("width", width)
            .attr("height", height);

        const context = canvas.node().getContext("2d");

        let projection = d3.geoOrthographic()
            .scale(Math.min(width, height) / 2 - 10)
            .translate([width / 2, height / 2]);

        let path = d3.geoPath().projection(projection).context(context);

        let world, auroraData;
        let userLocation = null;

        const colorScale = d3.scaleSequential(d3.interpolatePlasma)
            .domain([0, 100]);

        function loadData() {
            Promise.all([
                d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json"),
                d3.json("https://services.swpc.noaa.gov/json/ovation_aurora_latest.json")
            ]).then(function([worldData, aurora]) {
                world = worldData;
                auroraData = aurora;
                getUserLocation();
            });
        }

        function getUserLocation() {
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    userLocation = [longitude, latitude];
                    if (projection.rotate) {
                        projection.rotate([-longitude, -latitude]);
                    }
                    render();
                    drawColorbar();
                    updateMetadata();
                }, function(error) {
                    console.error("Error getting user location:", error);
                    render();
                    drawColorbar();
                    updateMetadata();
                });
            } else {
                console.log("Geolocation is not available");
                render();
                drawColorbar();
                updateMetadata();
            }
        }

        function render() {
            context.clearRect(0, 0, width, height);

            // Draw the globe
            context.beginPath();
            path({type: "Sphere"});
            context.fillStyle = SPHERE_FILL;
            context.fill();

            // Draw graticules
            const graticule = d3.geoGraticule()
                .stepMajor([90, 90])
                .stepMinor([45, 45]);

            context.beginPath();
            path(graticule());
            context.lineWidth = 0.5;
            context.strokeStyle = "rgba(255, 255, 255, 1)";
            context.stroke();

            auroraData.coordinates.forEach(d => {
                const [x, y] = projection(d.slice(0, 2));
                if (x !== null && y !== null) {
                    const [lon, lat] = d.slice(0, 2);

                    // Perform visibility filtering only for the orthographic projection
                    // if (selectedProjection === 'Orthographic') {
                        const [cx, cy] = projection.invert ? projection.invert([width / 2, height / 2]) : [0, 0];
                        const geoDistance = d3.geoDistance([lon, lat], [cx, cy]);

                        // Visibility filtering based on distance and intensity
                        if (d[2] > 0 && geoDistance < Math.PI / 2) {
                            drawAuroraPoint(x, y, d[2]);
                        }
                    // } else {
                    //     // For other projections, skip visibility filtering and only check intensity
                    //     if (d[2] > 0) {
                    //         drawAuroraPoint(x, y, d[2]);
                    //     }
                    // }
                }
            });

            // Helper function to draw aurora points
            function drawAuroraPoint(x, y, intensity) {
                context.beginPath();
                context.arc(x, y, 5, 0, 2 * Math.PI);
                context.fillStyle = colorScale(intensity);
                context.globalAlpha = intensity / 100;
                context.fill();
            }

            // // Draw aurora
            // auroraData.coordinates.forEach(d => {
            //     const [x, y] = projection(d.slice(0, 2));
            //     if (x !== null && y !== null) {
            //         const [lon, lat] = d.slice(0, 2);
            //         const [cx, cy] = projection.invert ? projection.invert([width/2, height/2]) : [0, 0];
            //         const geoDistance = d3.geoDistance([lon, lat], [cx, cy]);
            //         if (d[2] > 0 && (projection.clipAngle ? geoDistance < Math.PI / 2 : true)) {
            //             const intensity = d[2];
            //             context.beginPath();
            //             context.arc(x, y, 5, 0, 2 * Math.PI);
            //             context.fillStyle = colorScale(intensity);
            //             context.globalAlpha = intensity / 100;
            //             context.fill();
            //         }
            //     }
            // });
            context.globalAlpha = 1;

            // Draw countries
            context.beginPath();
            path(topojson.feature(world, world.objects.countries));
            context.fillStyle = COUNTRY_FILL;
            context.fill();

            // Draw country boundaries
            context.beginPath();
            path(topojson.mesh(world, world.objects.countries, (a, b) => a !== b));
            context.strokeStyle = COUNTRY_BORDER_STROKE;
            context.lineWidth = 0.5;
            context.stroke();

            // Draw coastlines
            context.beginPath();
            path(topojson.feature(world, world.objects.land));
            context.strokeStyle = "white";
            context.lineWidth = 0.5;
            context.stroke();

            // Draw user location if checkbox is checked
            if (document.getElementById('show-location').checked && userLocation) {
                const [x, y] = projection(userLocation);
                context.beginPath();
                context.arc(x, y, 5, 0, 2 * Math.PI);
                context.fillStyle = 'red';
                context.fill();
                context.strokeStyle = 'white';
                context.lineWidth = 2;
                context.stroke();
            }
        }

        function drawColorbar() {
            const colorbarCanvas = d3.select("#colorbar")
                .attr("width", 80)
                .attr("height", 200);
            const colorbarContext = colorbarCanvas.node().getContext("2d");
            const gradient = colorbarContext.createLinearGradient(0, 200, 0, 0);
            
            for (let i = 0; i <= 1; i += 0.01) {
                gradient.addColorStop(i, colorScale(i * 100));
            }
            
            colorbarContext.fillStyle = gradient;
            colorbarContext.fillRect(0, 0, 20, 200);
            
            // Add labels
            colorbarContext.fillStyle = "white";
            colorbarContext.font = "12px Arial";
            colorbarContext.textAlign = "left";
            colorbarContext.fillText("100%", 25, 10);
            colorbarContext.fillText("75%", 25, 55);
            colorbarContext.fillText("50%", 25, 105);
            colorbarContext.fillText("25%", 25, 155);
            colorbarContext.fillText("0%", 25, 195);
        }

        function updateMetadata() {
            const metadata = d3.select("#metadata");
            metadata.html(`
                Aurora Forecast Map<br>
                Orthographic projection<br>
                Observation Time: ${auroraData["Observation Time"]}<br>
                Forecast Time: ${auroraData["Forecast Time"]}<br>
                Render Time: ${new Date().toISOString()}<br>
            `);
        }

        function drag(projection) {
            let v0, q0, r0;

            function dragstarted(event) {
                const p = d3.pointers(event, this)[0];
                v0 = versor.cartesian(projection.invert(p));
                q0 = versor(r0 = projection.rotate());
            }

            function dragged(event) {
                const p = d3.pointers(event, this)[0];
                const v1 = versor.cartesian(projection.rotate(r0).invert(p));
                const q1 = versor.multiply(q0, versor.delta(v0, v1));
                projection.rotate(versor.rotation(q1));
                render();
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged);
        }

        d3.select("#globe").call(drag(projection));

        d3.select("#projection-select").on("change", function() {
    const selectedProjection = this.value;

    // Update projection based on user selection
    // if (selectedProjection === "orthographic") {
        projection = d3.geoOrthographic();
    // } else if (selectedProjection === "equalEarth") {
    //     projection = d3.geoEqualEarth();
    // } else if (selectedProjection === "robinson") {
    //     projection = d3.geoRobinson();
    // } else if (selectedProjection === "mollweide") {
    //     projection = d3.geoMollweide();
    // }

    // Update projection scale and translation
    projection.scale(Math.min(width, height) / 2 - 10).translate([width / 2, height / 2]);

    // Reset path with new projection
    path = d3.geoPath().projection(projection).context(context);

    // Remove existing drag events and reapply if projection supports rotation
    d3.select("#globe").on(".drag", null);
    if (projection.rotate) {
        d3.select("#globe").call(drag(projection));
    }

    render();
    updateMetadata();
});

        // Zoom functionality
        const zoom = d3.zoom()
            .scaleExtent([0.5, 4])
            .on("zoom", function(event) {
                const { transform } = event;
                projection.scale((Math.min(width, height) / 2 - 10) * transform.k);
                render();
            });

        d3.select("#globe").call(zoom);

        function resizeMap() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            d3.select("#globe")
                .attr("width", width)
                .attr("height", height);
            
            projection
                .scale(Math.min(width, height) / 2 - 10)
                .translate([width / 2, height / 2]);
            
            path = d3.geoPath().projection(projection).context(context);
            
            render();
        }

        window.addEventListener('resize', resizeMap);

        // Show controls when mouse is over the map window
        document.body.addEventListener('mouseover', function() {
            document.getElementById('controls').style.opacity = '1';
        });

        document.body.addEventListener('mouseout', function() {
            document.getElementById('controls').style.opacity = '0';
        });

        // Show user location when checkbox is changed
        document.getElementById('show-location').addEventListener('change', render);

        loadData();
    </script>
</body>
</html>
